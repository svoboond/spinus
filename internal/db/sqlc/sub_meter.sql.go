// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: sub_meter.sql

package spinusdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubMeter = `-- name: CreateSubMeter :one
INSERT INTO sub_meter (
	fk_main_meter, subid, meter_id, financial_balance, fk_user
) SELECT $1, COALESCE(MAX(subid), 0) + 1, $2, $3, $4
	FROM sub_meter
	WHERE fk_main_meter = $1
RETURNING id, fk_main_meter, subid, meter_id, financial_balance, fk_user
`

type CreateSubMeterParams struct {
	FkMainMeter      int32
	MeterID          pgtype.Text
	FinancialBalance float64
	FkUser           int32
}

func (q *Queries) CreateSubMeter(ctx context.Context, arg CreateSubMeterParams) (SubMeter, error) {
	row := q.db.QueryRow(ctx, createSubMeter,
		arg.FkMainMeter,
		arg.MeterID,
		arg.FinancialBalance,
		arg.FkUser,
	)
	var i SubMeter
	err := row.Scan(
		&i.ID,
		&i.FkMainMeter,
		&i.Subid,
		&i.MeterID,
		&i.FinancialBalance,
		&i.FkUser,
	)
	return i, err
}

const getSubMeter = `-- name: GetSubMeter :one
SELECT
	sub_meter.id,
	sub_meter.fk_main_meter AS main_meter_id,
	sub_meter.subid,
	sub_meter.meter_id AS sub_meter_id,
	sub_meter.financial_balance,
	sub_meter.fk_user AS sub_user_id,
	sub_user.email AS sub_user_email,
	main_meter.address,
	main_meter.fk_user AS main_user_id,
	main_user.email AS main_user_email
FROM sub_meter
JOIN main_meter
	ON sub_meter.fk_main_meter = main_meter.id
JOIN spinus_user AS sub_user
	ON sub_meter.fk_user = sub_user.id
JOIN spinus_user AS main_user
	ON main_meter.fk_user = main_user.id
WHERE fk_main_meter = $1 AND subid = $2
LIMIT 1
`

type GetSubMeterParams struct {
	FkMainMeter int32
	Subid       int32
}

type GetSubMeterRow struct {
	ID               int32
	MainMeterID      int32
	Subid            int32
	SubMeterID       pgtype.Text
	FinancialBalance float64
	SubUserID        int32
	SubUserEmail     string
	Address          string
	MainUserID       int32
	MainUserEmail    string
}

func (q *Queries) GetSubMeter(ctx context.Context, arg GetSubMeterParams) (GetSubMeterRow, error) {
	row := q.db.QueryRow(ctx, getSubMeter, arg.FkMainMeter, arg.Subid)
	var i GetSubMeterRow
	err := row.Scan(
		&i.ID,
		&i.MainMeterID,
		&i.Subid,
		&i.SubMeterID,
		&i.FinancialBalance,
		&i.SubUserID,
		&i.SubUserEmail,
		&i.Address,
		&i.MainUserID,
		&i.MainUserEmail,
	)
	return i, err
}

const listSubMeters = `-- name: ListSubMeters :many
SELECT sub_meter.id, subid, meter_id, financial_balance, email
FROM sub_meter
JOIN spinus_user
	ON sub_meter.fk_user = spinus_user.id
WHERE fk_main_meter = $1
ORDER BY subid
`

type ListSubMetersRow struct {
	ID               int32
	Subid            int32
	MeterID          pgtype.Text
	FinancialBalance float64
	Email            string
}

func (q *Queries) ListSubMeters(ctx context.Context, fkMainMeter int32) ([]ListSubMetersRow, error) {
	rows, err := q.db.Query(ctx, listSubMeters, fkMainMeter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubMetersRow
	for rows.Next() {
		var i ListSubMetersRow
		if err := rows.Scan(
			&i.ID,
			&i.Subid,
			&i.MeterID,
			&i.FinancialBalance,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubMeterFinancialBalance = `-- name: UpdateSubMeterFinancialBalance :exec
UPDATE sub_meter
SET financial_balance = $2
WHERE id = $1
`

type UpdateSubMeterFinancialBalanceParams struct {
	ID               int32
	FinancialBalance float64
}

func (q *Queries) UpdateSubMeterFinancialBalance(ctx context.Context, arg UpdateSubMeterFinancialBalanceParams) error {
	_, err := q.db.Exec(ctx, updateSubMeterFinancialBalance, arg.ID, arg.FinancialBalance)
	return err
}
